# SecretChat
Обёртка над [Вконтакте](https://vk.com/) для зашифрованой переписки с людьми.

_Название проекта SecretChat выбрано по аналогии с секретными чатами в телеграме, чтобы пользователи могли зашифрованными сообщениями даже если телеграм будет заблакирован_

Авторы: Щетников Павел, Ханова Анна

# Черновой план презентации защиты:

## Описание сути проекта
Мы сделали приложение-обёртку над мессенджером, позволяющее шифровать и обмениваться дешифровать сообщениями.
На данный момент реализована обёртка над [Вконтакте](https://vk.com/), сообщения шифруются с помощью [one-time pad (OTP)](https://en.wikipedia.org/wiki/One-time_pad) шифрования, используется простой консольный интерфейс.
В разработке находится графический интерфейс.

Точки расширения:
- Основная точка расширения --- различные мессенджеры, различные шифрования.
Архитектура уровня Domain написана так, чтобы добавить новое шифрование или новый месенджер было как можно проще.

- Можно создавать различные классы диалогов со сколь угодно подробным содержанием сообщений. От просто текстовых до содержащих Attachment, стикер, emoji.

- Возможно, к защите проекта будет готова точка расширения, позволяющая позволяющая создавать различные стили графического интерфейса.

Павел занимался получением информации об объектах с помощью VkApi, а также реализацией интерфейса, позволяющего легко добавлять другие мессенджеры. Анна работали над реализацией шифрования, консольным интерфейсом и тестированием.

## Описание точек расширения
### Разные виды мессенджеров
В основе абстракции лежат интерфейсы [IConnecter](https://github.com/Avel7884/SecretChat/blob/master/SecretChat/Domain/InteractionWithSomeMessanger/AbstractInteractionWithMessanger/IConnecter.cs) и [IDialog](https://github.com/Avel7884/SecretChat/blob/master/SecretChat/Domain/InteractionWithSomeMessanger/AbstractInteractionWithMessanger/IDialog.cs). IConnecter является фабрикой IDialog. Его задача установить соединение и создать диалог, в котором будут находиться указанные пользователи. IDialog имеет методы getMessages - получить непрочитанные ранее сообщения из этого диалога, sendMessage -- отправить сообщение. Эти методы не должны поддерживать шифрований.
Чтобы добавить новый мессенджер - нужно написать реализацию этих интерфейсов.
Также, если для удобного получения информации от мессенджера подразумевается работа с API, нужно реализовать интерфейс [IApiRequests](https://github.com/Avel7884/SecretChat/blob/master/SecretChat/Domain/InteractionWithSomeMessanger/AbstractInteractionWithMessanger/IApiRequests.cs). А чтобы получать больше информации о сообщениях, например, имя отправителя, нужно реализовать интерфейс [IUserManager](https://github.com/Avel7884/SecretChat/blob/master/SecretChat/Domain/InteractionWithSomeMessanger/AbstractInteractionWithMessanger/IUsersManager.cs).
Однако, если мы не хотим добавить новый мессенджер, а сделать другую реализацию работы с Vk, то можно будет переиспользовать значительную часть логики более низких уровней.

### Добавление новых видов шифрований.
Нужно реализовать абстрактный класс [MessageStream](https://github.com/Avel7884/SecretChat/blob/master/SecretChat/Domain/MessageEncryption/IMessageStream.cs), в него надо передать потоки, через которые пользователь будет взаимодействовать с приложением, а также методы ReadMessage и WriteMessage, которые будут читать/писать сообщения потоки и декодировать/кодировать, в соответствии с шифрованием.
Также, если для шифрования используется ключ, нужно реализовать интерфейс [IKeyReader](https://github.com/Avel7884/SecretChat/blob/master/SecretChat/Infrastructure/IKeyReader.cs), он знает как получить ключ возвращает следующие count байт ключа. 
  
## Структура решения.

  - В Infrastructure реализованы вспомогательные методы для работы с классом Bitmap, который мы использовали для визуализации игры.
  (https://github.com/Tinsane/WarChess/blob/master/WarChess/Infrastructure/BitmapUtils.cs)
  
  - Логика игры собрана в Domain. 
  Здесь есть классы и интерфейсы различного уровня абстракции,
  от подходящего любой игре с "полем" и "ходами" AbstractGame до собственно шахмат Chess.
  Самый низкий уровень абстракции - это класс [Game](https://github.com/Tinsane/WarChess/blob/master/WarChess/Domain/AbstractGame/Game.cs)
  Далее по иерархии наследования идёт [GridGame2D](https://github.com/Tinsane/WarChess/blob/master/WarChess/Domain/GridGame2D/GridGame2D.cs), данный класс сужает множество описываемых игр до игр, которые идут на конечной двумерной прямоугольной доске с квадратными клеточками.
  Далее идёт [ChessAlikeGame](https://github.com/Tinsane/WarChess/blob/master/WarChess/Domain/ChessAlike/ChessAlikeGame.cs) 
  Это игра на шахматном поле n\*m, в которой каждая фигура имеет один из двух цветов - белый и чёрный и известно какие фигуры ходят в данный момент.
  Ну и на последнем уровне абстракции - собственно ChessGame или какой-то другой класс, реализующий игру по конкретным правилам.
  Чтобы лучше понять архитектуру программы, рассмотрим класс ChessGame. Он наследуется от абстрактного класса ChessAlikeGame и реализует интерфейс IChessGame, поскольку является точкой соединения логики Domain и Application. Класс ChessGame является сервисом, который предоставляет интерфейс работы с сущностями ChessGameState и передает во "внешний мир" логику взаимодействия с игрой. Основной функцией для взаимодествия игры с "внешним миром" является функция TryMakeMove(ChessPosition from, ChessPosition to). Эта функция пытается подобрать подходящий ход для движения с позиции from, на позицию to, а потом пытается применить его к игре. Для индикации того, нашелся ли подходящий ход, данная функция возвращает булево значение. Ход же в свою очередь является просто функцией, которая принимает текущее состояние игры и другие опциональные аргументы и возвращает либо новое валидное состояние игры, если ход удался, либо null, если данный ход не может быть выполнен в данной ситуации. Сами же ходы все наследуются от DirectedMove из ChessAlike, который описывает ход, который совершается фигурой для перемещения.
  
  - В Application находятся классы-прослойки между классами уровня Domain и UserInterface.
    Они реализуют различную логику несвязанную напрямую с игрой.
    Например, класс [ChessAlikeApp](https://github.com/Tinsane/WarChess/blob/master/WarChess/Application/ChessAlikeApp.cs)
    реализует логику, связанную с выделением фигуры, которой будет производится ход.
    
  - Наконец, в UserInterface собраны все формы, контролы и прочие вещи, необходимые для визуализации.
    Во время реализации классов UserInterface мы старались делать Control-ы максимально глупыми.
    Это позволяет переиспользовать одни и те же контролы для разных игр.
    Например, контрол для шахматного поля [BoardControl](https://github.com/Tinsane/WarChess/blob/master/WarChess/UserInterface/BoardControl.cs) не знает ничего ни о каких шахматах. 
    Ему просто передают картинки и он их рисует.
    Также интересен [ChessAlikeGameControl](https://github.com/Tinsane/WarChess/blob/master/WarChess/UserInterface/ChessAlikeGameControl.cs), который принимает большое количество интерфейсов и реализует логику игры для произвольного IChessAlikeGame.
  
## DI-КОНТЕЙНЕР.
Интерфайс [IConnecter](https://github.com/Avel7884/SecretChat/blob/master/SecretChat/Domain/InteractionWithSomeMessanger/AbstractInteractionWithMessanger/IConnecter.cs) является фабрикой, поэтому [IDialog](https://github.com/Avel7884/SecretChat/blob/master/SecretChat/Domain/InteractionWithSomeMessanger/AbstractInteractionWithMessanger/IDialog.cs) собирается внутри него при помощи конвенций.
Остальное - явным конфигурированием.
Синглтонами сделаны класс работы с API, класс взаимодействия с пользователем, 
Также синглтоном является класс VKUsersManager, поскольку его логика всегда одинаковая.

## Тесты
Тестами пока покрыта логика шифрующая сообщения.
Проверяется корректность работы с длинными текстами, с кириллицей, пробелами, переводами строк и знаками препинания. Также, проверяется корректность работы с некоторыми алфавитами такими как японский, китайский упрощённый, арабский.
Для тестирования использовалась библиотека NUnit.
Логика уровня приложения оказалась очень простой, поэтому тестами мы её решили не покрывать.
